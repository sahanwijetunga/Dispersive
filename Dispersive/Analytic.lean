/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 06968294-0ab0-4f50-81bb-08d4156a3ece
-/

/-
We formalized the 1D Cauchy-Kowalevski theorem (Exercise 1.1) following the user's proof sketch.
We defined the Cauchy coefficients `cauchy_coeff`, proved bounds on them, constructed a candidate solution `u_candidate` as a power series, proved it is analytic and satisfies the ODE `u' = F(u)` with `u(0) = 0`.
Finally, we proved `cauchy_kowalevski_1D` which asserts the existence and uniqueness of a local analytic solution.
-/


import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Checking definitions
-/
#check iteratedDeriv
#check AnalyticOn
#check AnalyticAt

/-
Recursive definition of the functions $F_n$ used in the Cauchy-Kowalevski proof.
-/
open Set Filter

noncomputable def cauchy_coeff (F : ℝ → ℝ) : ℕ → (ℝ → ℝ)
| 0 => id
| (n+1) => fun x ↦ deriv (cauchy_coeff F n) x * F x

/-
Recursive formula for the derivatives of the Cauchy coefficients.
-/
open Set Filter BigOperators

theorem cauchy_coeff_succ_iteratedDeriv {F : ℝ → ℝ} {m k : ℕ} (hF : ContDiff ℝ ⊤ F) :
  iteratedDeriv k (cauchy_coeff F (m + 1)) =
  fun x ↦ ∑ j ∈ Finset.range (k + 1), (k.choose j : ℝ) * iteratedDeriv (j + 1) (cauchy_coeff F m) x * iteratedDeriv (k - j) F x := by
    -- We'll use mathematical induction to prove this formula.
    induction' k with k ih generalizing m;
    · -- The zeroth derivative of any function is just the function itself.
      simp [cauchy_coeff];
    · -- Apply the Leibniz rule to the expression from the induction hypothesis.
      have h_leibniz : ∀ x, deriv (fun x => ∑ j ∈ Finset.range (k + 1), Nat.choose k j * iteratedDeriv (j + 1) (cauchy_coeff F m) x * iteratedDeriv (k - j) F x) x = ∑ j ∈ Finset.range (k + 1), Nat.choose k j * iteratedDeriv (j + 2) (cauchy_coeff F m) x * iteratedDeriv (k - j) F x + ∑ j ∈ Finset.range (k + 1), Nat.choose k j * iteratedDeriv (j + 1) (cauchy_coeff F m) x * iteratedDeriv (k - j + 1) F x := by
        intro x
        have h_diff : ∀ j ∈ Finset.range (k + 1), DifferentiableAt ℝ (fun x => iteratedDeriv (j + 1) (cauchy_coeff F m) x) x ∧ DifferentiableAt ℝ (fun x => iteratedDeriv (k - j) F x) x := by
          have h_diff : ∀ n, ContDiff ℝ ⊤ (cauchy_coeff F n) := by
            intro n
            induction' n with n ih
            generalize_proofs at *;
            · exact contDiff_id;
            · apply_rules [ ContDiff.mul, ContDiff.fderiv_apply ];
              any_goals exact le_top;
              · fun_prop;
              · exact contDiff_id;
              · exact contDiff_const;
          have h_diff : ∀ n, ContDiff ℝ ⊤ (iteratedDeriv n (cauchy_coeff F m)) := by
            intro n; induction' n with n ih <;> simp_all +decide [ iteratedDeriv_succ ] ;
            apply_rules [ ContDiff.fderiv_apply, ih ];
            any_goals exact le_top;
            · fun_prop;
            · exact contDiff_id;
            · exact contDiff_const;
          have h_diff : ∀ n, ContDiff ℝ ⊤ (iteratedDeriv n F) := by
            intro n; induction' n with n ih <;> simp_all +decide [ iteratedDeriv_succ ] ;
            apply_rules [ ContDiff.fderiv_apply, ih ];
            any_goals exact le_top;
            · fun_prop;
            · exact contDiff_id;
            · exact contDiff_const;
          exact fun j hj => ⟨ by have := ‹∀ n, ContDiff ℝ ⊤ ( iteratedDeriv n ( cauchy_coeff F m ) ) › ( j + 1 ) ; exact this.contDiffAt.differentiableAt le_top, by have := h_diff ( k - j ) ; exact this.contDiffAt.differentiableAt le_top ⟩;
        convert ( HasDerivAt.deriv <| HasDerivAt.sum fun j hj => ?_ ) using 1;
        congr! 1;
        exact
          Eq.symm
            (Finset.sum_fn (Finset.range (k + 1)) fun c a ↦
              ↑(k.choose c) * iteratedDeriv (c + 1) (cauchy_coeff F m) a *
                iteratedDeriv (k - c) F a);
        rw [ ← Finset.sum_add_distrib ];
        convert HasDerivAt.mul ( HasDerivAt.mul ( hasDerivAt_const _ _ ) ( h_diff j hj |>.1.hasDerivAt ) ) ( h_diff j hj |>.2.hasDerivAt ) using 1 ; ring_nf!;
        norm_num [ add_comm, add_left_comm, add_assoc, iteratedDeriv_succ ] ; ring_nf!;
        norm_num [ add_comm 2 j, iteratedDeriv_succ ] ; ring!;
      ext x; simp_all +decide [ iteratedDeriv_succ ];
      rw [ Finset.sum_range_succ, Finset.sum_range_succ' ];
      rw [ Finset.sum_range_succ, Finset.sum_range_succ' ] ; norm_num [ Nat.choose_succ_succ, add_comm, add_left_comm, add_assoc ];
      simp +decide [add_mul, Finset.sum_add_distrib, iteratedDeriv_succ];
      refine' Finset.sum_congr rfl fun i hi => _;
      rw [ show k - i = ( k - ( i + 1 ) ) + 1 by rw [ tsub_add_eq_add_tsub ( by linarith [ Finset.mem_range.mp hi ] ) ] ; simp +decide ] ; simp +decide [ iteratedDeriv_succ ]


/-
Bound on the derivatives of the Cauchy coefficients.
-/
open Set Filter BigOperators

theorem cauchy_coeff_bound
  {F : ℝ → ℝ} (hF_an : AnalyticOn ℝ F univ)
  (hF_bound : ∀ n, |iteratedDeriv n F 0| ≤ (Nat.factorial n : ℝ))
  {K : ℝ} (hK : K ≥ 2) :
  ∀ m j, |iteratedDeriv j (cauchy_coeff F m) 0| ≤ (Nat.factorial (j + m) : ℝ) * K ^ (j + 2 * m + 1) := by
    -- We proceed by induction on $m$.
    intro m
    induction' m with m ih;
    · unfold cauchy_coeff;
      rintro ( _ | _ | j ) <;> norm_num [ iteratedDeriv_succ' ];
      · linarith;
      · linarith [ le_abs_self K ];
      · norm_num [ iteratedDeriv ];
        positivity;
    · -- Applying the induction hypothesis and the bound on $F^{(k-j)}(0)$.
      intros k
      have h_sum : |iteratedDeriv k (cauchy_coeff F (m + 1)) 0| ≤ ∑ j ∈ Finset.range (k + 1), (Nat.choose k j : ℝ) * (Nat.factorial (j + m + 1)) * K ^ (j + 2 * m + 2) * (Nat.factorial (k - j)) := by
        have h_sum : |iteratedDeriv k (cauchy_coeff F (m + 1)) 0| ≤ ∑ j ∈ Finset.range (k + 1), (Nat.choose k j : ℝ) * |iteratedDeriv (j + 1) (cauchy_coeff F m) 0| * |iteratedDeriv (k - j) F 0| := by
          rw [ cauchy_coeff_succ_iteratedDeriv ];
          · exact le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( Finset.sum_le_sum fun _ _ => by rw [ abs_mul, abs_mul, abs_of_nonneg ( Nat.cast_nonneg _ : ( 0 : ℝ ) ≤ _ ) ] );
          · exact AnalyticOn.contDiff hF_an;
        refine le_trans h_sum <| Finset.sum_le_sum fun j hj => ?_;
        convert mul_le_mul ( mul_le_mul_of_nonneg_left ( ih ( j + 1 ) ) ( Nat.cast_nonneg _ ) ) ( hF_bound ( k - j ) ) ( by positivity ) ( by positivity ) using 1 ; ring_nf;
      -- We can factor out $(k + m + 1)!$ from the sum.
      have h_factor : ∑ j ∈ Finset.range (k + 1), (Nat.choose k j : ℝ) * (Nat.factorial (j + m + 1)) * K ^ (j + 2 * m + 2) * (Nat.factorial (k - j)) ≤ (Nat.factorial (k + m + 1)) * K ^ (2 * m + 2) * ∑ j ∈ Finset.range (k + 1), K ^ j := by
        have h_factor : ∀ j ∈ Finset.range (k + 1), (Nat.choose k j : ℝ) * (Nat.factorial (j + m + 1)) * (Nat.factorial (k - j)) ≤ (Nat.factorial (k + m + 1)) := by
          intro j hj; rw [ Nat.cast_choose ] <;> try linarith [ Finset.mem_range.mp hj ] ;
          field_simp;
          norm_cast;
          -- By simplifying, we can see that the inequality holds.
          have h_simp : ∀ j k m : ℕ, j ≤ k → Nat.factorial k * Nat.factorial (j + m + 1) ≤ Nat.factorial j * Nat.factorial (k + m + 1) := by
            intros j k m hjk; induction' hjk with k hk ih <;> simp_all +decide [ Nat.factorial ] ;
            rw [ show k + 1 + m = k + m + 1 by ring, Nat.factorial_succ ];
            nlinarith [ Nat.zero_le ( k.factorial * ( ( j + m + 1 ) * ( j + m ).factorial ) ), Nat.zero_le ( j.factorial * ( ( k + m + 1 ) * ( k + m ).factorial ) ), Nat.factorial_succ k, Nat.factorial_succ ( k + m ) ];
          exact h_simp j k m ( Finset.mem_range_succ_iff.mp hj );
        rw [ Finset.mul_sum _ _ _ ];
        exact Finset.sum_le_sum fun i hi => by convert mul_le_mul_of_nonneg_right ( h_factor i hi ) ( show 0 ≤ K ^ ( i + 2 * m + 2 ) by positivity ) using 1 <;> ring;
      -- We can bound the sum $\sum_{j=0}^k K^j$ by $K^{k+1}$ since $K \geq 2$.
      have h_sum_bound : ∑ j ∈ Finset.range (k + 1), K ^ j ≤ K ^ (k + 1) := by
        nlinarith [ geom_sum_mul K ( k + 1 ), pow_pos ( zero_lt_two.trans_le hK ) ( k + 1 ) ];
      refine le_trans h_sum <| le_trans h_factor ?_;
      exact le_trans ( mul_le_mul_of_nonneg_left h_sum_bound <| by positivity ) <| by ring_nf; norm_num;

/-
The power series defined by the Cauchy coefficients converges in a neighborhood of 0.
-/
open Set Filter BigOperators

noncomputable def cauchy_power_series_coeff (F : ℝ → ℝ) (n : ℕ) : ℝ :=
  cauchy_coeff F n 0 / Nat.factorial n

theorem cauchy_series_convergence
  {F : ℝ → ℝ} (hF_an : AnalyticOn ℝ F univ)
  (hF_bound : ∀ n, |iteratedDeriv n F 0| ≤ (Nat.factorial n : ℝ))
  {K : ℝ} (hK : K ≥ 2) :
  ∃ R > 0, ∀ x : ℝ, |x| < R → Summable (fun n ↦ cauchy_power_series_coeff F n * x ^ n) := by
    -- Use the bound $|F_m(0)| \le m! K^{2m+1}$.
    have h_bound : ∀ m : ℕ, abs ((cauchy_coeff F m 0) / (m.factorial : ℝ)) ≤ K ^ (2 * m + 1) := by
      -- Apply the bound on the Cauchy coefficients to get the inequality.
      intros m
      have h_cauchy_coeff_bound : |(cauchy_coeff F m 0)| ≤ (Nat.factorial m : ℝ) * K ^ (2 * m + 1) := by
        have := cauchy_coeff_bound hF_an hF_bound hK m 0 ; aesop
      simp_all +decide [ abs_div ];
      rwa [ div_le_iff₀' ( by positivity ) ];
    unfold cauchy_power_series_coeff;
    use 1 / K ^ 2, by positivity, fun x hx ↦ ?_;
    -- Using the bound, we can show that the series converges absolutely.
    have h_abs_conv : Summable (fun n => abs ((cauchy_coeff F n 0) / (n.factorial : ℝ)) * abs x ^ n) := by
      refine Summable.of_nonneg_of_le ( fun n => mul_nonneg ( abs_nonneg _ ) ( pow_nonneg ( abs_nonneg _ ) _ ) ) ( fun n => mul_le_mul_of_nonneg_right ( h_bound n ) ( pow_nonneg ( abs_nonneg _ ) _ ) ) ?_;
      -- Factor out $K$ from the series.
      suffices h_series : Summable (fun n => K * (K^2 * |x|)^n) by
        convert h_series using 2 ; ring;
      exact Summable.mul_left _ <| summable_geometric_of_lt_one ( by positivity ) <| by rw [ lt_div_iff₀ <| by positivity ] at hx; nlinarith;
    exact Summable.of_norm <| by simpa [ abs_div, abs_mul, mul_div_right_comm ] using h_abs_conv;

/-
Candidate solution $u$ defined as a power series.
-/
open Set Filter BigOperators

noncomputable def u_candidate (F : ℝ → ℝ) (x : ℝ) : ℝ := ∑' n, cauchy_power_series_coeff F n * x ^ n

/-
Checking availability of FormalMultilinearSeries.ofScalars
-/
#check FormalMultilinearSeries.ofScalars

/-
Formal power series for the candidate solution.
-/
open Set Filter BigOperators

noncomputable def u_formal_series (F : ℝ → ℝ) : FormalMultilinearSeries ℝ ℝ ℝ :=
  FormalMultilinearSeries.ofScalars ℝ (fun n ↦ cauchy_power_series_coeff F n)

/-
The formal power series applied to a vector gives the expected term.
-/
open Set Filter BigOperators

theorem u_formal_series_apply (F : ℝ → ℝ) (n : ℕ) (y : ℝ) :
  (u_formal_series F n) (fun _ ↦ y) = cauchy_power_series_coeff F n * y ^ n := by
    unfold u_formal_series FormalMultilinearSeries.ofScalars; aesop;

/-
The candidate solution has a power series expansion on a ball.
-/
open Set Filter BigOperators

theorem u_hasFPowerSeriesOnBall
  {F : ℝ → ℝ} (hF_an : AnalyticOn ℝ F univ)
  (hF_bound : ∀ n, |iteratedDeriv n F 0| ≤ (Nat.factorial n : ℝ))
  {K : ℝ} (hK : K ≥ 2) :
  ∃ R > 0, HasFPowerSeriesOnBall (u_candidate F) (u_formal_series F) 0 (ENNReal.ofReal R) := by
    have := cauchy_series_convergence hF_an hF_bound hK;
    obtain ⟨ R, hR₀, hR ⟩ := this;
    use R / 2, half_pos hR₀;
    constructor;
    · refine' le_trans _ ( le_ciSup _ ⟨ R / 2, by positivity ⟩ );
      · refine' le_trans _ ( le_ciSup _ ( ∑' n, ‖u_formal_series F n‖ * ( R / 2 ) ^ n ) );
        · rw [ ciSup_pos ];
          · norm_num [ ENNReal.ofReal ];
            norm_num [ Real.toNNReal_le_iff_le_coe ];
          · intro n; exact Summable.le_tsum ( show Summable fun n => ‖u_formal_series F n‖ * ( R / 2 ) ^ n from by
                                                convert hR ( R / 2 ) ( by rw [ abs_of_pos ] <;> linarith ) |> Summable.norm using 2 ; norm_num [ u_formal_series ];
                                                exact Or.inl ( by rw [ abs_of_pos hR₀ ] ) ) n ( fun n _ => by positivity ) ;
        · refine' ⟨ ⊤, Set.forall_mem_range.2 fun C => _ ⟩ ; aesop;
      · norm_num +zetaDelta at *;
    · positivity;
    · norm_num +zetaDelta at *;
      intro y hy; convert hR y ( by linarith ) |> Summable.hasSum using 1 ; norm_num [ u_candidate, u_formal_series ] ; ring_nf;

/-
The candidate solution is analytic on a neighborhood of 0.
-/
open Set Filter BigOperators

theorem u_candidate_analytic
  {F : ℝ → ℝ} (hF_an : AnalyticOn ℝ F univ)
  (hF_bound : ∀ n, |iteratedDeriv n F 0| ≤ (Nat.factorial n : ℝ))
  {K : ℝ} (hK : K ≥ 2) :
  ∃ R > 0, AnalyticOn ℝ (u_candidate F) (Metric.ball 0 R) := by
    field_simp;
    obtain ⟨ R, hR ⟩ := u_hasFPowerSeriesOnBall hF_an hF_bound hK;
    have := hR.2;
    have := this.analyticOnNhd;
    exact ⟨ R, hR.1, this.analyticOn.mono <| by simp +decide [ Metric.ball ] ⟩

/-
The derivatives of the candidate solution at 0 match the Cauchy coefficients.
-/
open Set Filter BigOperators

theorem u_candidate_iteratedDeriv
  {F : ℝ → ℝ} (hF_an : AnalyticOn ℝ F univ)
  (hF_bound : ∀ n, |iteratedDeriv n F 0| ≤ (Nat.factorial n : ℝ))
  {K : ℝ} (hK : K ≥ 2) :
  ∀ n, iteratedDeriv n (u_candidate F) 0 = cauchy_coeff F n 0 := by
    intro n;
    -- By definition of the candidate solution, we know that its derivatives at 0 are given by the Cauchy coefficients. We can use the fact that the formal power series converges to the function in a neighborhood of 0.
    obtain ⟨R, hR_pos, hR⟩ : ∃ R > 0, HasFPowerSeriesOnBall (u_candidate F) (u_formal_series F) 0 (ENNReal.ofReal R) := by
      exact u_hasFPowerSeriesOnBall hF_an hF_bound hK;
    have := hR.hasFPowerSeriesAt;
    have := this.analyticAt;
    have := this.hasFPowerSeriesAt;
    have h_series_eq : ∀ n, (u_formal_series F n) = (FormalMultilinearSeries.ofScalars ℝ (fun n => iteratedDeriv n (u_candidate F) 0 / (n.factorial : ℝ)) n) := by
      have h_series_eq : u_formal_series F = FormalMultilinearSeries.ofScalars ℝ (fun n => iteratedDeriv n (u_candidate F) 0 / (n.factorial : ℝ)) := by
        (expose_names; exact HasFPowerSeriesAt.eq_formalMultilinearSeries this_1 this);
      exact fun n => congr_arg ( fun f => f n ) h_series_eq;
    specialize h_series_eq n; simp_all +decide [ FormalMultilinearSeries.ofScalars ] ;
    replace h_series_eq := congr_arg ( fun f => f ( fun _ => 1 ) ) h_series_eq ; simp_all +decide [ ];
    rw [ eq_div_iff ( by positivity ) ] at h_series_eq;
    rw [ ← h_series_eq, u_formal_series ];
    simp +decide [ cauchy_power_series_coeff ];
    rw [ div_mul_cancel₀ _ ( by positivity ) ]

/-
The operator `cauchy_op` satisfies the derivation property.
-/
open Set Filter BigOperators

noncomputable def cauchy_op (F : ℝ → ℝ) (G : ℝ → ℝ) : ℝ → ℝ := fun x ↦ deriv G x * F x

theorem cauchy_op_deriv (F G H : ℝ → ℝ) (x : ℝ) (hG : DifferentiableAt ℝ G x) (hH : DifferentiableAt ℝ H x) :
  cauchy_op F (G * H) x = cauchy_op F G x * H x + G x * cauchy_op F H x := by
    have h_deriv : deriv (G * H) x = deriv G x * H x + G x * deriv H x := by
      exact deriv_mul hG hH;
    exact Eq.symm ( by rw [ show cauchy_op F ( G * H ) x = deriv ( G * H ) x * F x by rfl ] ; rw [ show cauchy_op F G x = deriv G x * F x by rfl ] ; rw [ show cauchy_op F H x = deriv H x * F x by rfl ] ; rw [ h_deriv ] ; ring )

/-
Linearity of `cauchy_op` with respect to addition.
-/
open Set Filter BigOperators

theorem cauchy_op_add (F G H : ℝ → ℝ) (x : ℝ)
  (hG : DifferentiableAt ℝ G x) (hH : DifferentiableAt ℝ H x) :
  cauchy_op F (G + H) x = cauchy_op F G x + cauchy_op F H x := by
    unfold cauchy_op; norm_num [ hG, hH, deriv_add ] ; ring;

/-
Linearity of `cauchy_op` with respect to scalar multiplication.
-/
open Set Filter BigOperators

theorem cauchy_op_smul (F G : ℝ → ℝ) (c : ℝ) (x : ℝ)
  (hG : DifferentiableAt ℝ G x) :
  cauchy_op F (c • G) x = c • cauchy_op F G x := by
    unfold cauchy_op;
    erw [ deriv_const_mul ] ; ring_nf!;
    · norm_num [ mul_assoc ];
    · assumption

/-
Linearity of `cauchy_op` with respect to finite sums.
-/
open Set Filter BigOperators

theorem cauchy_op_sum {ι : Type*} (s : Finset ι) (F : ℝ → ℝ) (G : ι → ℝ → ℝ) (x : ℝ)
  (hG : ∀ i ∈ s, DifferentiableAt ℝ (G i) x) :
  cauchy_op F (fun y ↦ ∑ i ∈ s, G i y) x = ∑ i ∈ s, cauchy_op F (G i) x := by
    -- Apply the linearity of the derivative and the definition of `cauchy_op`.
    have h_deriv : deriv (fun y => ∑ i ∈ s, G i y) x = ∑ i ∈ s, deriv (G i) x := by
      exact deriv_fun_sum hG;
    unfold cauchy_op; simp +decide [ h_deriv, Finset.sum_mul ] ;

/-
Combinatorial identity for the Leibniz rule proof.
-/
open Set Filter BigOperators

theorem sum_choose_succ {α : Type*} [CommRing α] (n : ℕ) (a b : ℕ → α) :
  (∑ j ∈ Finset.range (n + 1), (n.choose j : α) * a (j + 1) * b (n - j)) +
  (∑ j ∈ Finset.range (n + 1), (n.choose j : α) * a j * b (n - j + 1)) =
  ∑ j ∈ Finset.range (n + 2), ((n + 1).choose j : α) * a j * b (n + 1 - j) := by
    rw [ Finset.sum_range_succ, Finset.sum_range_succ' ];
    rw [ Finset.sum_range_succ, Finset.sum_range_succ' ];
    simp +decide [ Nat.choose_succ_succ, add_mul, add_assoc, add_comm, add_left_comm, Finset.sum_add_distrib ];
    exact Finset.sum_congr rfl fun x hx => by rw [ show 1 + ( n - ( x + 1 ) ) = n - x from by linarith [ Nat.sub_add_cancel ( show x + 1 ≤ n from by linarith [ Finset.mem_range.mp hx ] ), Nat.sub_add_cancel ( show x ≤ n from by linarith [ Finset.mem_range.mp hx ] ) ] ] ;

/-
The operator `cauchy_op` preserves smoothness.
-/
open Set Filter BigOperators

theorem cauchy_op_smooth {F G : ℝ → ℝ} (hF : ContDiff ℝ ⊤ F) (hG : ContDiff ℝ ⊤ G) :
  ContDiff ℝ ⊤ (cauchy_op F G) := by
    apply_rules [ ContDiff.mul ];
    apply_rules [ ContDiff.fderiv_apply, hG ];
    any_goals exact le_top;
    · fun_prop;
    · exact contDiff_id;
    · exact contDiff_const

/-
Iterated application of `cauchy_op` preserves smoothness.
-/
open Set Filter BigOperators

theorem cauchy_op_iterate_smooth {F G : ℝ → ℝ} (n : ℕ) (hF : ContDiff ℝ ⊤ F) (hG : ContDiff ℝ ⊤ G) :
  ContDiff ℝ ⊤ ((cauchy_op F)^[n] G) := by
    induction' n with n ih generalizing G <;> simp_all +decide [ Function.iterate_succ_apply' ];
    exact cauchy_op_smooth hF (ih hG)


/-
The Cauchy coefficients are obtained by iterating the Cauchy operator on the identity function.
-/
open Set Filter BigOperators

theorem cauchy_coeff_eq_iterate
  (F : ℝ → ℝ) (n : ℕ) :
  cauchy_coeff F n = (cauchy_op F)^[n] id := by
    induction' n with n ih generalizing F <;> simp_all +decide [Function.iterate_succ_apply'];
    · rfl;
    · unfold cauchy_coeff; aesop;

/-
The iterated Cauchy operator satisfies the Leibniz rule.
-/
open Set Filter BigOperators

theorem cauchy_op_leibniz
  {F : ℝ → ℝ} {G H : ℝ → ℝ} {n : ℕ}
  (hF : ContDiff ℝ ⊤ F) (hG : ContDiff ℝ ⊤ G) (hH : ContDiff ℝ ⊤ H) :
  (cauchy_op F)^[n] (G * H) = fun x ↦ ∑ k ∈ Finset.range (n + 1), (n.choose k : ℝ) * ((cauchy_op F)^[k] G x) * ((cauchy_op F)^[n - k] H x) := by
    induction' n with n ih generalizing G H <;> simp_all +decide [ Function.iterate_succ_apply' ];
    · rfl;
    · -- Apply the induction hypothesis to rewrite the sum.
      have h_ind : cauchy_op F (fun x => ∑ k ∈ Finset.range (n + 1), (Nat.choose n k : ℝ) * (cauchy_op F)^[k] G x * (cauchy_op F)^[n - k] H x) =
        fun x => ∑ k ∈ Finset.range (n + 1), (Nat.choose n k : ℝ) * (cauchy_op F)^[k + 1] G x * (cauchy_op F)^[n - k] H x +
        ∑ k ∈ Finset.range (n + 1), (Nat.choose n k : ℝ) * (cauchy_op F)^[k] G x * (cauchy_op F)^[n - k + 1] H x := by
          ext x;
          -- Apply the linearity of the derivative and the product rule.
          have h_deriv : deriv (fun x => ∑ k ∈ Finset.range (n + 1), (Nat.choose n k : ℝ) * (cauchy_op F)^[k] G x * (cauchy_op F)^[n - k] H x) x = ∑ k ∈ Finset.range (n + 1), (Nat.choose n k : ℝ) * deriv (fun x => (cauchy_op F)^[k] G x * (cauchy_op F)^[n - k] H x) x := by
            have h_deriv : ∀ k ∈ Finset.range (n + 1), DifferentiableAt ℝ (fun x => (cauchy_op F)^[k] G x * (cauchy_op F)^[n - k] H x) x := by
              intro k hk
              have h_diff : ContDiff ℝ ⊤ ((cauchy_op F)^[k] G) ∧ ContDiff ℝ ⊤ ((cauchy_op F)^[n - k] H) := by
                exact ⟨ Nat.recOn k hG fun n ihn => by rw [ Function.iterate_succ_apply' ] ; exact cauchy_op_smooth hF ihn, Nat.recOn ( n - k ) hH fun n ihn => by rw [ Function.iterate_succ_apply' ] ; exact cauchy_op_smooth hF ihn ⟩;
              exact DifferentiableAt.mul ( h_diff.1.contDiffAt.differentiableAt le_top ) ( h_diff.2.contDiffAt.differentiableAt le_top );
            norm_num [ mul_assoc, h_deriv ];
            convert HasDerivAt.deriv ( HasDerivAt.sum fun k hk => HasDerivAt.const_mul ( n.choose k : ℝ ) ( h_deriv k hk |> DifferentiableAt.hasDerivAt ) ) using 1;
            exact congr_arg ( deriv · x ) ( funext fun _ => by simp +decide [ Finset.sum_apply ] );
          convert congr_arg ( fun y => y * F x ) h_deriv using 1;
          rw [ Finset.sum_mul _ _ _ ] ; rw [ ← Finset.sum_add_distrib ] ; refine' Finset.sum_congr rfl fun i hi => _ ; erw [ deriv_mul ] <;> norm_num [ Function.iterate_succ_apply' ] ; ring_nf;
          · unfold cauchy_op; ring;
          · have h_diff : ∀ i, ContDiff ℝ ⊤ ((cauchy_op F)^[i] G) := by
              intro i; induction i <;> simp_all +decide [Function.iterate_succ_apply'] ;
              (expose_names; exact cauchy_op_smooth hF h);
            exact ( h_diff i |> ContDiff.differentiable <| by norm_num ) x;
          · refine' ( cauchy_op_iterate_smooth _ _ _ |> ContDiff.differentiable <| by norm_num ) x;
            · assumption;
            · assumption;
      ext x; rw [ h_ind ] ; rw [ Finset.sum_range_succ, Finset.sum_range_succ' ] ; simp +decide [Nat.choose_succ_succ,
        add_mul, add_assoc, add_left_comm, Finset.sum_add_distrib] ;
      rw [ Finset.sum_range_succ, Finset.sum_range_succ' ] ; simp +decide [add_comm, add_left_comm,
        add_assoc] ; ring_nf;
      refine' Finset.sum_congr rfl fun i hi => _ ; rw [ show n - i = n - ( 1 + i ) + 1 from tsub_eq_of_eq_add <| by linarith [ Nat.sub_add_cancel <| show 1 + i ≤ n from by linarith [ Finset.mem_range.mp hi ] ] ] ; simp +decide [ Function.iterate_succ_apply' ] ; ring_nf;
      exact Or.inl ( by erw [ Function.iterate_succ_apply' ] )

/-
The derivatives of $u'$ at 0 are given by iterating the Cauchy operator on $F$.
-/
open Set Filter BigOperators

theorem u_deriv_eq_cauchy_op_F
  {F : ℝ → ℝ} (hF_an : AnalyticOn ℝ F univ)
  (hF_bound : ∀ n, |iteratedDeriv n F 0| ≤ (Nat.factorial n : ℝ))
  {K : ℝ} (hK : K ≥ 2) :
  ∀ k, iteratedDeriv k (deriv (u_candidate F)) 0 = (cauchy_op F)^[k] F 0 := by
    -- By the properties of iterated derivatives and the definition of the Cauchy operator, we can show that the k-th derivative of the derivative of u_candidate F at 0 is equal to the k-th iteration of the Cauchy operator applied to F at 0.
    have h_deriv : ∀ k, iteratedDeriv k (deriv (u_candidate F)) 0 = iteratedDeriv (k + 1) (u_candidate F) 0 := by
      intro k;
      rw [ iteratedDeriv_succ' ];
    intro k;
    rw [ h_deriv, u_candidate_iteratedDeriv ];
    rw [ cauchy_coeff_eq_iterate ];
    any_goals assumption;
    unfold cauchy_op; aesop;

/-
Recurrence relation for the iterated derivative of a composition with u.
-/
open Set Filter BigOperators

theorem iteratedDeriv_succ_comp_u
  {u : ℝ → ℝ} (hu_an : AnalyticOn ℝ u (Metric.ball 0 1)) -- Assuming u is analytic near 0
  {G : ℝ → ℝ} (hG_an : AnalyticOn ℝ G univ)
  (n : ℕ) :
  iteratedDeriv (n + 1) (G ∘ u) 0 = ∑ k ∈ Finset.range (n + 1), (n.choose k : ℝ) * iteratedDeriv k (deriv G ∘ u) 0 * iteratedDeriv (n - k) (deriv u) 0 := by
    -- Applying the Leibniz rule to the nth derivative of $(deriv G ∘ u) * (deriv u)$.
    have h_leibniz : iteratedDeriv n ((deriv G ∘ u) * (deriv u)) 0 = ∑ k ∈ Finset.range (n + 1), (n.choose k : ℝ) * iteratedDeriv k (deriv G ∘ u) 0 * iteratedDeriv (n - k) (deriv u) 0 := by
      have h_leibniz : ∀ x, x ∈ Metric.ball 0 1 → iteratedDeriv n ((deriv G ∘ u) * deriv u) x = ∑ k ∈ Finset.range (n + 1), (n.choose k : ℝ) * iteratedDeriv k (deriv G ∘ u) x * iteratedDeriv (n - k) (deriv u) x := by
        intro x hx;
        have h_leibniz : ∀ {f g : ℝ → ℝ} {n : ℕ}, ContDiffOn ℝ ⊤ f (Metric.ball 0 1) → ContDiffOn ℝ ⊤ g (Metric.ball 0 1) → ∀ x ∈ Metric.ball 0 1, iteratedDeriv n (f * g) x = ∑ k ∈ Finset.range (n + 1), (n.choose k : ℝ) * iteratedDeriv k f x * iteratedDeriv (n - k) g x := by
          intros f g n hf hg x hx;
          induction' n with n ih generalizing x <;> simp_all +decide [ iteratedDeriv_succ ];
          -- Apply the product rule to each term in the sum.
          have h_prod_rule : deriv (fun x => ∑ k ∈ Finset.range (n + 1), (Nat.choose n k : ℝ) * iteratedDeriv k f x * iteratedDeriv (n - k) g x) x = ∑ k ∈ Finset.range (n + 1), (Nat.choose n k : ℝ) * (iteratedDeriv (k + 1) f x * iteratedDeriv (n - k) g x + iteratedDeriv k f x * iteratedDeriv (n - k + 1) g x) := by
            convert HasDerivAt.deriv ( HasDerivAt.sum fun i hi => HasDerivAt.const_mul ( Nat.choose n i : ℝ ) <| HasDerivAt.mul ( hasDerivAt_deriv_iff.mpr <| show DifferentiableAt ℝ ( fun x => iteratedDeriv i f x ) x from ?_ ) <| hasDerivAt_deriv_iff.mpr <| show DifferentiableAt ℝ ( fun x => iteratedDeriv ( n - i ) g x ) x from ?_ ) using 1;
            any_goals exact Finset.range ( n + 1 );
            · exact congr_arg ( deriv · x ) ( by ext; simp +decide [ mul_assoc ] );
            · congr! 3;
              · rw [ iteratedDeriv_succ ];
              · rw [ iteratedDeriv_succ ];
            · have h_diff : ∀ k ≤ n, ContDiffOn ℝ ⊤ (iteratedDeriv k f) (Metric.ball 0 1) := by
                intro k hk; induction' k with k ih <;> simp_all +decide [ iteratedDeriv_succ ] ;
                exact ih ( Nat.le_of_succ_le hk ) |> fun h => h.deriv_of_isOpen Metric.isOpen_ball ( by aesop );
              exact ( h_diff i ( Finset.mem_range_succ_iff.mp hi ) |> ContDiffOn.differentiableOn <| by norm_num ) |> DifferentiableOn.differentiableAt <| Metric.isOpen_ball.mem_nhds <| by simpa using hx;
            · have h_diff : ∀ k, ContDiffOn ℝ ⊤ (iteratedDeriv k g) (Metric.ball 0 1) := by
                intro k; induction' k with k ih <;> simp_all +decide [ iteratedDeriv_succ ] ;
                exact ih.deriv_of_isOpen Metric.isOpen_ball le_top;
              exact ( h_diff _ |> ContDiffOn.differentiableOn <| by norm_num ) |> DifferentiableOn.differentiableAt <| Metric.isOpen_ball.mem_nhds <| by simpa using hx;
          convert h_prod_rule using 1;
          · exact Filter.EventuallyEq.deriv_eq ( Filter.eventuallyEq_of_mem ( IsOpen.mem_nhds ( isOpen_lt continuous_abs continuous_const ) hx ) fun y hy => ih y hy );
          · rw [ Finset.sum_range_succ' ];
            norm_num [ Nat.choose_succ_succ, mul_add, add_mul, mul_assoc, mul_comm, mul_left_comm, Finset.sum_add_distrib ];
            rw [ Finset.sum_range_succ' ];
            rw [ Finset.sum_range_succ ] ; norm_num [ Nat.choose_succ_succ, mul_assoc, mul_comm, mul_left_comm, Finset.sum_range_succ' ] ; ring_nf;
            simp +decide [add_comm, add_left_comm, add_assoc];
            exact Finset.sum_congr rfl fun i hi => by rw [ show 1 + ( n - ( i + 1 ) ) = n - i from by linarith [ Nat.sub_add_cancel ( show i + 1 ≤ n from by linarith [ Finset.mem_range.mp hi ] ), Nat.sub_add_cancel ( show i ≤ n from by linarith [ Finset.mem_range.mp hi ] ) ] ] ;
        apply_rules [ AnalyticOn.contDiffOn, h_leibniz ];
        · have h_deriv_G_an : AnalyticOn ℝ (deriv G) univ := by
            simp +zetaDelta at *;
            exact hG_an.deriv;
          exact h_deriv_G_an.comp hu_an fun x hx => Set.mem_univ _;
        · exact Metric.isOpen_ball.uniqueDiffOn;
        · apply_rules [ ContDiffOn.analyticOn, hu_an ];
          apply_rules [ ContDiffOn.deriv_of_isOpen, hu_an.contDiffOn ];
          any_goals exact le_top;
          · exact Metric.isOpen_ball.uniqueDiffOn;
          · exact Metric.isOpen_ball;
        · exact Metric.isOpen_ball.uniqueDiffOn;
      exact h_leibniz 0 <| Metric.mem_ball_self zero_lt_one;
    convert h_leibniz using 1;
    -- By definition of iteratedDeriv, we have
    have h_iter : ∀ x ∈ Metric.ball 0 1, deriv (G ∘ u) x = deriv G (u x) * deriv u x := by
      exact fun x hx => deriv_comp x ( hG_an.differentiableOn.differentiableAt ( by simp ) ) ( hu_an.differentiableOn.differentiableAt ( Metric.isOpen_ball.mem_nhds hx ) );
    have h_iter : ∀ x ∈ Metric.ball 0 1, deriv^[n+1] (G ∘ u) x = deriv^[n] (deriv G ∘ u * deriv u) x := by
      intro x hx;
      have h_iter : ∀ m : ℕ, ∀ x ∈ Metric.ball 0 1, deriv^[m + 1] (G ∘ u) x = deriv^[m] (deriv G ∘ u * deriv u) x := by
        intro m x hx; induction' m with m ih generalizing x <;> simp_all +decide [ Function.iterate_succ_apply' ] ;
        exact Filter.EventuallyEq.deriv_eq ( Filter.eventuallyEq_of_mem ( IsOpen.mem_nhds ( isOpen_lt continuous_abs continuous_const ) hx ) fun y hy => ih y hy );
      exact h_iter n x hx;
    convert h_iter 0 ( by norm_num ) using 1 <;> norm_num [ iteratedDeriv_eq_iterate ]

/-
The Leibniz rule for the iterated derivative of a product of functions.
-/
open Set Filter BigOperators

theorem iteratedDeriv_mul
  {f g : ℝ → ℝ} {n : ℕ} {x : ℝ}
  (hf : ContDiffAt ℝ n f x) (hg : ContDiffAt ℝ n g x) :
  iteratedDeriv n (f * g) x = ∑ k ∈ Finset.range (n + 1), (n.choose k : ℝ) * iteratedDeriv k f x * iteratedDeriv (n - k) g x := by
    induction' n with n ih generalizing x;
    · simp +decide [ iteratedDeriv ];
    · rw [ iteratedDeriv_succ ];
      -- Apply the product rule to each term in the sum.
      have h_prod_rule : deriv (fun x => ∑ k ∈ Finset.range (n + 1), (Nat.choose n k : ℝ) * iteratedDeriv k f x * iteratedDeriv (n - k) g x) x =
        ∑ k ∈ Finset.range (n + 1), (Nat.choose n k : ℝ) * (iteratedDeriv (k + 1) f x * iteratedDeriv (n - k) g x + iteratedDeriv k f x * iteratedDeriv (n - k + 1) g x) := by
          have h_prod_rule : ∀ k ∈ Finset.range (n + 1), DifferentiableAt ℝ (fun x => iteratedDeriv k f x) x ∧ DifferentiableAt ℝ (fun x => iteratedDeriv (n - k) g x) x := by
            intro k hk;
            have h_diff : ∀ m ≤ n, ContDiffAt ℝ (↑(n + 1 - m)) (iteratedDeriv m f) x ∧ ContDiffAt ℝ (↑(n + 1 - m)) (iteratedDeriv m g) x := by
              intro m hm
              induction' m with m ih generalizing x
              aesop
              generalize_proofs at *;
              have := ih ( show ContDiffAt ℝ ( n + 1 ) f x from hf ) ( show ContDiffAt ℝ ( n + 1 ) g x from hg ) ( Nat.le_of_succ_le hm ) ; simp_all +decide [tsub_add_eq_tsub_tsub] ;
              simp_all +decide [ iteratedDeriv_succ ];
              constructor <;> apply_rules [ ContDiffAt.clm_apply, this.1, this.2 ];
              · apply_rules [ ContDiffAt.fderiv, this.1 ];
                any_goals exact le_rfl;
                · convert this.1.comp ( x, x ) ( contDiffAt_snd ) using 1 ; simp +decide [ Nat.sub_sub ];
                  rw [ Nat.succ_sub ( by linarith ), Nat.cast_succ ];
                · exact contDiffAt_id;
              · exact contDiffAt_const;
              · have h_diff : ContDiffAt ℝ (↑(n + 1 - m - 1) + 1) (iteratedDeriv m g) x := by
                  convert this.2 using 1;
                  norm_cast;
                  omega;
                exact h_diff.fderiv_right ( by norm_num );
              · exact contDiffAt_const;
            simp +zetaDelta at *;
            exact ⟨ ( h_diff k ( Nat.le_of_lt_succ hk ) |>.1.differentiableAt ( by norm_num; omega ) ), ( h_diff ( n - k ) ( Nat.sub_le _ _ ) |>.2.differentiableAt ( by norm_num; omega ) ) ⟩;
          convert deriv_sum _ using 2;
          rotate_left;
          rotate_left;
          use fun k x => ( Nat.choose n k : ℝ ) * iteratedDeriv k f x * iteratedDeriv ( n - k ) g x;
          · exact fun k hk => DifferentiableAt.mul ( DifferentiableAt.mul ( differentiableAt_const _ ) ( h_prod_rule k hk |>.1 ) ) ( h_prod_rule k hk |>.2 );
          · aesop;
          · norm_num [ h_prod_rule _ ‹_›, mul_assoc, mul_comm, mul_left_comm ];
            rw [ iteratedDeriv_succ, iteratedDeriv_succ ] ; ring;
      convert h_prod_rule using 1;
      · refine' Filter.EventuallyEq.deriv_eq _;
        filter_upwards [ hf.eventually ( by aesop ), hg.eventually ( by aesop ) ] with y hy₁ hy₂ using ih ( hy₁.of_le <| by norm_num ) ( hy₂.of_le <| by norm_num );
      · rw [ Finset.sum_range_succ', Finset.sum_range_succ ];
        rw [ Finset.sum_range_succ ];
        simp +decide [Nat.choose_succ_succ, mul_add, mul_comm, mul_left_comm,
          Finset.sum_add_distrib];
        have := Finset.sum_range_sub' ( fun k => iteratedDeriv k f x * ( Nat.choose n k * iteratedDeriv ( n - k + 1 ) g x ) ) n; simp_all +decide [mul_comm,
          mul_left_comm] ;
        rw [ show ( ∑ k ∈ Finset.range n, iteratedDeriv ( n - k ) g x * ( iteratedDeriv ( k + 1 ) f x * ↑ ( n.choose ( k + 1 ) ) ) ) = ∑ k ∈ Finset.range n, iteratedDeriv ( k + 1 ) f x * ( iteratedDeriv ( n - ( k + 1 ) + 1 ) g x * ↑ ( n.choose ( k + 1 ) ) ) from Finset.sum_congr rfl fun i hi => by rw [ tsub_add_eq_add_tsub ( by linarith [ Finset.mem_range.mp hi ] ) ] ; simp +decide [mul_left_comm] ] ; linarith

/-
Recurrence relation for the iterated derivative of a composition with u, on a ball of radius R.
-/
open Set Filter BigOperators

theorem iteratedDeriv_succ_comp_u_general
  {u : ℝ → ℝ} {R : ℝ} (hR : 0 < R) (hu_an : AnalyticOn ℝ u (Metric.ball 0 R))
  {G : ℝ → ℝ} (hG_an : AnalyticOn ℝ G univ)
  (n : ℕ) :
  iteratedDeriv (n + 1) (G ∘ u) 0 = ∑ k ∈ Finset.range (n + 1), (n.choose k : ℝ) * iteratedDeriv k (deriv G ∘ u) 0 * iteratedDeriv (n - k) (deriv u) 0 := by
    -- By the chain rule, we have that the derivative of $G \circ u$ is $(deriv G \circ u) * deriv u$.
    have h_chain : ∀ x ∈ Metric.ball 0 R, deriv (G ∘ u) x = (deriv G ∘ u) x * deriv u x := by
      exact fun x hx => deriv_comp x ( hG_an.differentiableOn.differentiableAt ( by simp ) ) ( hu_an.differentiableOn.differentiableAt ( Metric.isOpen_ball.mem_nhds hx ) );
    -- Apply the Leibniz rule to the product $(deriv G \circ u) * deriv u$.
    have h_leibniz : iteratedDeriv n ((deriv G ∘ u) * deriv u) 0 = ∑ k ∈ Finset.range (n + 1), (n.choose k : ℝ) * iteratedDeriv k (deriv G ∘ u) 0 * iteratedDeriv (n - k) (deriv u) 0 := by
      apply_rules [ iteratedDeriv_mul ];
      · -- Since $u$ is analytic on the ball of radius $R$ around $0$, and $G$ is analytic on the entire real line, their composition $deriv G \circ u$ is analytic on the ball of radius $R$ around $0$.
        have h_comp : AnalyticOn ℝ (deriv G ∘ u) (Metric.ball 0 R) := by
          have h_comp : AnalyticOn ℝ (deriv G) univ := by
            simp +zetaDelta at *;
            exact hG_an.deriv;
          exact h_comp.comp hu_an fun x hx => Set.mem_univ _;
        have := h_comp 0 ( Metric.mem_ball_self hR );
        exact this.contDiffWithinAt.contDiffAt ( Metric.isOpen_ball.mem_nhds <| Metric.mem_ball_self hR );
      · have h_cont_diff_deriv : ContDiffOn ℝ ⊤ (deriv u) (Metric.ball 0 R) := by
          apply_rules [ ContDiffOn.deriv_of_isOpen, hu_an.contDiffOn ];
          exacts [ Metric.isOpen_ball.uniqueDiffOn, ⊤, Metric.isOpen_ball, by norm_num ];
        exact h_cont_diff_deriv.contDiffAt ( Metric.ball_mem_nhds _ hR ) |> ContDiffAt.of_le <| by norm_num;
    rw [ ← h_leibniz, iteratedDeriv_succ' ];
    rw [ Filter.EventuallyEq.iteratedDeriv_eq ];
    filter_upwards [ Metric.ball_mem_nhds 0 hR ] with x hx using h_chain x hx


/-
If u matches the Cauchy coefficients of F, then the derivatives of G ∘ u at 0 are given by iterating the Cauchy operator on G.
-/
open Set Filter BigOperators

def MatchesCauchyCoeffs (F : ℝ → ℝ) (u : ℝ → ℝ) : Prop :=
  ∀ n, iteratedDeriv n u 0 = cauchy_coeff F n 0

theorem iteratedDeriv_comp_u_eq_cauchy_op_power
  {F : ℝ → ℝ} (hF_an : AnalyticOn ℝ F univ)
  {u : ℝ → ℝ} {R : ℝ} (hR : 0 < R) (hu_an : AnalyticOn ℝ u (Metric.ball 0 R))
  (hu_match : MatchesCauchyCoeffs F u)
  {G : ℝ → ℝ} (hG_an : AnalyticOn ℝ G univ)
  (n : ℕ) :
  iteratedDeriv n (G ∘ u) 0 = (cauchy_op F)^[n] G 0 := by
    -- By definition of $MatchesCauchyCoeffs$, we know that $u$ matches the Cauchy coefficients of $F$.
    have hu_coeff : ∀ n, iteratedDeriv n u 0 = cauchy_coeff F n 0 := by
      exact hu_match;
    induction' n using Nat.strong_induction_on with n ih generalizing G u;
    rcases n with ( _ | n );
    · specialize hu_coeff 0 ; aesop;
    · -- By the Leibniz rule, we have:
      have h_leibniz : iteratedDeriv (n + 1) (G ∘ u) 0 = ∑ k ∈ Finset.range (n + 1), Nat.choose n k * iteratedDeriv k (deriv G ∘ u) 0 * iteratedDeriv (n - k) (deriv u) 0 := by
        apply_rules [ iteratedDeriv_succ_comp_u_general ];
      -- By the induction hypothesis, we have:
      have h_ind : ∀ k ∈ Finset.range (n + 1), iteratedDeriv k (deriv G ∘ u) 0 = (cauchy_op F)^[k] (deriv G) 0 := by
        intros k hk;
        apply ih k (by linarith [Finset.mem_range.mp hk]) hu_an hu_match;
        · simp +zetaDelta at *;
          exact hG_an.deriv;
        · assumption;
      -- By the induction hypothesis, we have that $iteratedDeriv (n - k) (deriv u) 0 = cauchy_coeff F (n - k + 1) 0$.
      have h_ind_deriv : ∀ k ∈ Finset.range (n + 1), iteratedDeriv (n - k) (deriv u) 0 = cauchy_coeff F (n - k + 1) 0 := by
        intro k hk; specialize hu_coeff ( n - k + 1 ) ; simp_all +decide [ iteratedDeriv_succ ] ;
        rw [ ← hu_coeff, iteratedDeriv_eq_iterate ];
        rw [ iteratedDeriv_eq_iterate ];
        erw [ Function.iterate_succ_apply' ];
      -- By the properties of the Cauchy operator, we have:
      have h_cauchy_op : (cauchy_op F)^[n + 1] G 0 = ∑ k ∈ Finset.range (n + 1), Nat.choose n k * (cauchy_op F)^[k] (deriv G) 0 * (cauchy_op F)^[n - k] F 0 := by
        have h_cauchy_op : ∀ m, (cauchy_op F)^[m] (deriv G * F) = fun x => ∑ k ∈ Finset.range (m + 1), Nat.choose m k * (cauchy_op F)^[k] (deriv G) x * (cauchy_op F)^[m - k] F x := by
          intro m;
          convert cauchy_op_leibniz _ _ _ using 1;
          · exact AnalyticOn.contDiff hF_an;
          · apply_rules [ ContDiff.fderiv_apply, hG_an.contDiff ];
            any_goals exact le_top;
            · exact hG_an.contDiff.comp ( contDiff_snd );
            · exact contDiff_id;
            · exact contDiff_const;
          · exact AnalyticOn.contDiff hF_an;
        convert congr_fun ( h_cauchy_op n ) 0 using 1;
      simp_all +decide [ cauchy_coeff_eq_iterate ];
      unfold cauchy_op; aesop;

/-
The candidate solution u satisfies the differential equation u' = F(u) on a neighborhood of 0.
-/
open Set Filter BigOperators

theorem u_satisfies_ODE
  {F : ℝ → ℝ} (hF_an : AnalyticOn ℝ F univ)
  (hF_bound : ∀ n, |iteratedDeriv n F 0| ≤ (Nat.factorial n : ℝ))
  {K : ℝ} (hK : K ≥ 2) :
  ∃ R > 0, ∀ t ∈ Metric.ball 0 R, deriv (u_candidate F) t = F (u_candidate F t) := by
    -- To show that the derivatives of $u'$ and $F \circ u$ at $0$ match, we use the fact that they are equal at $0$ and their derivatives match there.
    have h_deriv_match : ∀ k, iteratedDeriv k (deriv (u_candidate F)) 0 = iteratedDeriv k (F ∘ u_candidate F) 0 := by
      -- By the properties of the candidate solution and the Cauchy operator, we have that the k-th derivative of the derivative of u_candidate F at 0 is equal to the k-th derivative of F ∘ u_candidate F at 0.
      intros k
      have h_deriv : iteratedDeriv k (deriv (u_candidate F)) 0 = (cauchy_op F)^[k] F 0 := by
        exact u_deriv_eq_cauchy_op_F hF_an hF_bound hK k;
      rw [ h_deriv, iteratedDeriv_comp_u_eq_cauchy_op_power ];
      any_goals exact hF_an;
      exact Classical.choose ( u_candidate_analytic hF_an hF_bound hK );
      · exact Classical.choose_spec ( u_candidate_analytic hF_an hF_bound hK ) |>.1;
      · exact ( Classical.choose_spec ( u_candidate_analytic hF_an hF_bound hK ) ) |>.2;
      · exact fun n => by simpa using u_candidate_iteratedDeriv hF_an hF_bound hK n;
    -- By the uniqueness theorem for analytic functions, if two analytic functions have the same derivatives at a point, they are equal in some neighborhood of that point.
    have h_unique : ∀ {g h : ℝ → ℝ}, AnalyticAt ℝ g 0 → AnalyticAt ℝ h 0 → (∀ k, iteratedDeriv k g 0 = iteratedDeriv k h 0) → ∃ R > 0, ∀ t ∈ Metric.ball 0 R, g t = h t := by
      intros g h hg hh h_eq_derivs
      have h_unique : ∀ᶠ t in nhds 0, g t = h t := by
        have := hg.hasFPowerSeriesAt;
        have := hh.hasFPowerSeriesAt; simp_all +decide [ hasFPowerSeriesAt_iff, iteratedDeriv_eq_iterate ] ;
        filter_upwards [ ‹∀ᶠ z in nhds 0, HasSum ( fun n => z ^ n * ( deriv^[n] h 0 / ( n ! : ℝ ) ) ) ( g z ) ›, ‹∀ᶠ z in nhds 0, HasSum ( fun n => z ^ n * ( deriv^[n] h 0 / ( n ! : ℝ ) ) ) ( h z ) › ] with z hz₁ hz₂ using hz₁.unique hz₂;
      exact Metric.mem_nhds_iff.mp h_unique;
    apply h_unique;
    · -- The derivative of an analytic function is also analytic.
      have h_deriv_analytic : AnalyticAt ℝ (u_candidate F) 0 := by
        have := @u_hasFPowerSeriesOnBall;
        specialize this hF_an hF_bound hK;
        obtain ⟨ R, hR₀, hR ⟩ := this; exact hR.analyticAt;
      exact h_deriv_analytic.deriv;
    · apply_rules [ AnalyticAt.comp, hF_an ];
      any_goals apply_rules [ analyticAt_id, analyticAt_const ];
      · exact analyticWithinAt_univ.mp (hF_an (u_candidate F 0) trivial);
      · have := @u_hasFPowerSeriesOnBall;
        specialize this hF_an hF_bound hK;
        obtain ⟨ R, hR₀, hR ⟩ := this; exact hR.analyticAt;
    · assumption

/-
Any local analytic solution has derivatives at 0 given by the Cauchy coefficients.
-/
open Set Filter BigOperators

structure IsLocalAnalyticSolution (F : ℝ → ℝ) (u : ℝ → ℝ) : Prop where
  analytic : AnalyticAt ℝ u 0
  init : u 0 = 0
  ode : ∀ᶠ t in nhds 0, deriv u t = F (u t)

theorem solution_coeffs_match
  {F : ℝ → ℝ} (hF_an : AnalyticOn ℝ F univ)
  {u : ℝ → ℝ} (hu : IsLocalAnalyticSolution F u) :
  ∀ n, iteratedDeriv n u 0 = cauchy_coeff F n 0 := by
    -- By Lemma iteratedDeriv_comp_u_eq_cauchy_op_power, we know that the iterated derivatives of G ∘ u at 0 are given by iterating the Cauchy operator on G.
    have h_iterated_deriv_comp : ∀ (n : ℕ) (G : ℝ → ℝ), ContDiff ℝ ⊤ G → iteratedDeriv n (G ∘ u) 0 = (cauchy_op F)^[n] G 0 := by
      obtain ⟨ R, hR_pos, hR ⟩ := hu;
      intro n G hG_an; induction' n with n ih generalizing G <;> simp_all +decide [ Function.iterate_succ_apply' ] ;
      rw [ iteratedDeriv_succ' ];
      -- By the chain rule, we have $\frac{d}{dt}(G \circ u)(t) = G'(u(t)) \cdot u'(t)$.
      have h_chain_rule : ∀ᶠ t in nhds 0, deriv (G ∘ u) t = deriv G (u t) * deriv u t := by
        filter_upwards [ R.eventually_analyticAt, hR ] with t ht ht' using deriv_comp t ( hG_an.differentiable le_top _ ) ( ht.differentiableAt );
      -- By the chain rule, we have $\frac{d}{dt}(G \circ u)(t) = G'(u(t)) \cdot u'(t)$. Since $u'(t) = F(u(t))$, we get $\frac{d}{dt}(G \circ u)(t) = G'(u(t)) \cdot F(u(t))$.
      have h_chain_rule_simplified : ∀ᶠ t in nhds 0, deriv (G ∘ u) t = deriv G (u t) * F (u t) := by
        filter_upwards [ h_chain_rule, hR ] with t ht₁ ht₂ using by rw [ ht₁, ht₂ ] ;
      -- Apply the induction hypothesis to the function $H(t) = deriv G (u t) * F (u t)$.
      have h_induction_step : iteratedDeriv n (fun t => deriv G (u t) * F (u t)) 0 = (cauchy_op F)^[n] (fun t => deriv G t * F t) 0 := by
        convert ih ( fun t => deriv G t * F t ) _ using 1;
        apply_rules [ ContDiff.mul, ContDiff.fderiv_apply ];
        any_goals exact le_top;
        · fun_prop;
        · exact contDiff_id;
        · exact contDiff_const;
        · exact contDiff_omega_iff_analyticOnNhd.mpr hF_an;
      convert h_induction_step using 1;
      · rw [ Filter.EventuallyEq.iteratedDeriv_eq ] ; aesop;
      · erw [ Function.iterate_succ_apply' ];
    intro n;
    convert h_iterated_deriv_comp n ( fun x => x ) ( contDiff_id ) using 1;
    rw [ cauchy_coeff_eq_iterate ];
    rfl

/-
The Cauchy-Kowalevski theorem (1D case): There exists a unique local analytic solution to the ODE u' = F(u), u(0) = 0.
-/
open Set Filter BigOperators

theorem cauchy_kowalevski_1D
  {F : ℝ → ℝ} (hF_an : AnalyticOn ℝ F univ)
  (hF_bound : ∀ n, |iteratedDeriv n F 0| ≤ (Nat.factorial n : ℝ))
  {K : ℝ} (hK : K ≥ 2) :
  (∃ u, IsLocalAnalyticSolution F u) ∧
  (∀ u v, IsLocalAnalyticSolution F u → IsLocalAnalyticSolution F v → u =ᶠ[nhds 0] v) := by
    constructor;
    · -- Let's choose the candidate solution $u$ from the previous steps.
      use u_candidate F;
      constructor;
      · have := u_hasFPowerSeriesOnBall hF_an hF_bound hK;
        rcases this with ⟨ R, hR₀, hR ⟩ ; exact hR.analyticAt;
      · have := u_candidate_iteratedDeriv hF_an hF_bound hK 0; aesop;
      · exact ( u_satisfies_ODE hF_an hF_bound hK ) |> fun ⟨ R, hR₀, hR ⟩ => Metric.eventually_nhds_iff.2 ⟨ R, hR₀, fun t ht => hR t ht ⟩;
    · -- By solution_coeffs_match, u^(n)(0) = cauchy_coeff F n 0 and v^(n)(0) = cauchy_coeff F n 0.
      intro u v hu hv
      have h_eq : ∀ n, iteratedDeriv n u 0 = iteratedDeriv n v 0 := by
        exact fun n => by rw [ solution_coeffs_match hF_an hu, solution_coeffs_match hF_an hv ] ;
      have := hu.analytic;
      have := this.hasFPowerSeriesAt;
      have := hv.analytic.hasFPowerSeriesAt;
      simp_all +decide [ hasFPowerSeriesAt_iff ];
      filter_upwards [ this, ‹∀ᶠ z in nhds 0, HasSum ( fun n => z ^ n * ( iteratedDeriv n v 0 / ( n ! : ℝ ) ) ) ( u z ) › ] with x hx₁ hx₂ using hx₂.unique hx₁
